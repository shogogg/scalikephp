<?php
/**
 * Copyright (c) 2021 shogogg <shogo@studiofly.net>.
 *
 * This software is released under the MIT License.
 * http://opensource.org/licenses/mit-license.php
 */
declare(strict_types=1);

namespace ScalikePHP\Support;

use Closure;
use InvalidArgumentException;
use ScalikePHP\ArraySeq;
use ScalikePHP\Seq;
use ScalikePHP\TraversableSeq;
use Traversable;

/**
 * Seq building functions.
 */
trait SeqBuilder
{
    private static ?Seq $empty = null;

    /**
     * Returns a {@link \ScalikePHP\Seq} of values generated by closure.
     *
     * @param Closure $f
     * @return \ScalikePHP\Seq
     */
    final public static function create(Closure $f): Seq
    {
        return self::fromTraversable(new ClosureIterator($f));
    }

    /**
     * Returns the empty {@link \ScalikePHP\Seq}.
     *
     * @return \ScalikePHP\Seq
     */
    final public static function empty(): Seq
    {
        if (self::$empty === null) {
            self::$empty = new ArraySeq([]);
        }
        return self::$empty;
    }

    /**
     * Returns the empty {@link \ScalikePHP\Seq}.
     *
     * @return \ScalikePHP\Seq
     * @deprecated
     */
    final public static function emptySeq(): Seq
    {
        return self::empty();
    }

    /**
     * Returns a {@link \ScalikePHP\Seq} of items.
     *
     * @param array $items
     * @return \ScalikePHP\Seq
     */
    final public static function from(...$items): Seq
    {
        return new ArraySeq($items);
    }

    /**
     * Returns a {@link \ScalikePHP\Seq} from iterable.
     *
     * @param null|iterable $iterable
     * @throws InvalidArgumentException
     * @return \ScalikePHP\Seq
     */
    final public static function fromArray(?iterable $iterable): Seq
    {
        if ($iterable === null) {
            return self::empty();
        } elseif (is_array($iterable)) {
            return empty($iterable) ? static::empty() : new ArraySeq((array)$iterable);
        } elseif ($iterable instanceof Traversable) {
            return self::fromTraversable($iterable);
        } else {
            throw new InvalidArgumentException('Seq::fromArray() needs to iterable');
        }
    }

    /**
     * Returns a {@link \ScalikePHP\Seq} from {@link Traversable}.
     *
     * @param Traversable $traversable
     * @return \ScalikePHP\Seq
     */
    final public static function fromTraversable(Traversable $traversable): Seq
    {
        return new TraversableSeq($traversable);
    }

    /**
     * Returns a {@link \ScalikePHP\Seq} from given iterables.
     *
     * @param iterable[] $iterables
     * @return \ScalikePHP\Seq
     */
    final public static function merge(iterable ...$iterables): Seq
    {
        return self::create(function () use ($iterables) {
            $i = 0;
            foreach ($iterables as $iterable) {
                foreach ($iterable as $x) {
                    yield $i++ => $x;
                }
            }
        });
    }
}
