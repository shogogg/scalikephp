<?php
/**
 * Copyright (c) 2021 shogogg <shogo@studiofly.net>.
 *
 * This software is released under the MIT License.
 * http://opensource.org/licenses/mit-license.php
 */
declare(strict_types=1);

namespace ScalikePHP\Support;

use Closure;
use ScalikePHP\Implementations\ArraySeq;
use ScalikePHP\Implementations\TraversableSeq;
use ScalikePHP\Seq;
use Traversable;

/**
 * Seq building functions.
 */
trait SeqBuilder
{
    private static ?Seq $empty = null;

    /**
     * Returns a Seq of values generated by closure.
     *
     * @param \Closure $f
     * @return \ScalikePHP\Seq
     */
    final public static function create(\Closure $f): Seq
    {
        return self::fromTraversable(new ClosureIterator($f));
    }

    /**
     * Returns the empty Seq.
     *
     * @return \ScalikePHP\Seq
     */
    final public static function empty(): Seq
    {
        if (self::$empty === null) {
            self::$empty = new ArraySeq([]);
        }
        return self::$empty;
    }

    /**
     * Returns the empty Seq.
     *
     * @return \ScalikePHP\Seq
     * @deprecated Use `Seq::empty()` instead.
     */
    final public static function emptySeq(): Seq
    {
        return self::empty();
    }

    /**
     * Returns a Seq of items.
     *
     * @param array $items
     * @return \ScalikePHP\Seq
     */
    final public static function from(...$items): Seq
    {
        return new ArraySeq($items);
    }

    /**
     * Returns a Seq from iterable.
     *
     * @param null|iterable $iterable
     * @throws \InvalidArgumentException
     * @return \ScalikePHP\Seq
     */
    final public static function fromArray(?iterable $iterable): Seq
    {
        if ($iterable === null) {
            return self::empty();
        } elseif (is_array($iterable)) {
            return empty($iterable) ? self::empty() : new ArraySeq((array)$iterable);
        } elseif ($iterable instanceof \Traversable) {
            return self::fromTraversable($iterable);
        } else {
            throw new \InvalidArgumentException('Seq::fromArray() needs to iterable');
        }
    }

    /**
     * Returns a Seq from a Traversable.
     *
     * @param \Traversable $traversable
     * @return \ScalikePHP\Seq
     */
    final public static function fromTraversable(\Traversable $traversable): Seq
    {
        return new TraversableSeq($traversable);
    }

    /**
     * Returns a Seq from given iterables.
     *
     * @param iterable[] $iterables
     * @return \ScalikePHP\Seq
     */
    final public static function merge(iterable ...$iterables): Seq
    {
        return self::create(function () use ($iterables) {
            $i = 0;
            foreach ($iterables as $iterable) {
                foreach ($iterable as $x) {
                    yield $i++ => $x;
                }
            }
        });
    }
}
